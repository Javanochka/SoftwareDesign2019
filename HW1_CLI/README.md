# Архитектура интерпретатора

Картинка с [архитектурой](https://drive.google.com/file/d/18sBRBnxMI9HFh471jfk_1EhTefoCFWFD/view?usp=sharing)


Вся архитектура разбивается на три блока: интерпретатор, парсер и команды.

Парсер умеет только бить строчки на команды с параметрами, а команды на слова.

Интерпретатор в себе хранит переменные в скоупе, умеет их подставлять и запускать команды.
Внутри интерепретатора хранится так же таблица доступных внутренних команд: по строчке получается функция, создающая команду.
Именно интерпретатор занимается передачей ввода-вывода при pipe-ах.

Все команды наследуются от одного класса и имеют одинаковый вид. Принимают на вход параметры, поток ввода и поток вывода.

Парсер и интерпретатор умеют бросать исключения парсера -- в случае, если произошла некоторая ошибка при чтении файлов.

Команды и интерпретатор умеют бросать исключения команд, если произошла некоторая ошибка при исполнении команды.

# Библиотека для аргементов

Было рассмотрено мной несколько библиотек для парсинга аргментов:

* JCommander
* JCommando
* jargs
* argparser

Была выбрана JCommander по следующим причинам:

* Много пользователей, подробная и понятная документация
* Управление в коде, а не посредством отдельных файлов (как в случае с JCommando)
* Универсальность для разных ОС и настраиваемость


